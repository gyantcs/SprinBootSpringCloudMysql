Spring Boot Mysql app to demonstrate 3 different ways of configuration on Pivotal Cloud Foundry

== 1. Let Java Buildpack Autoreconfiguration handle it. 

```diff
+ See cf-db-services-sample-auto folder
```

The simplest approach is to do nothing and let Cloud Foundry's Java Buildpack handle the details.
Cloud Foundry's Java Buildpack injects a library called the https://github.com/cloudfoundry/java-buildpack-auto-reconfiguration[Java Buildpack Auto Reconfiguration] into the runtime deployable
which reconfigures the service connectivity appropriately.

Check the Manifest file called 'manifest.yml' under the folder **-auto. It has the service that this App will bind to that is picked up by the Spring Auto connector with this line. 

```diff
+  services:
-  mydb
```
###### Note: You will create a service on your PCF Org with Name "mydb" that will be of type Mysql.

== 2. Use Java Environment properties. 

```diff
+ See cf-db-services-sample-props folder
```
Spring Boot exposes the VCAP_SERVICES properties which is in the form of a JSON into a more consumable format - as simple environment properties. These properties can be used for configuring
the connectivity to the service

== 3. Use Spring Cloud Connector. 

```diff
+ See cf-db-services-sample-connector folder. 
```

```pytoon
@Configuration
@Profile("cloud")
public  class CloudFoundryDatabaseConfig {

    @Bean
    public Cloud cloud() {
        return new CloudFactory().getCloud();
    }

    @Bean
    public DataSource dataSource() {
        DataSource dataSource = cloud().getServiceConnector("mydb", DataSource.class, null);
        return dataSource;
    }
}

```
http://cloud.spring.io/spring-cloud-connectors/[Spring Cloud Connector] provides the most advanced configuration for enabling connectivity to an external service.

Any of the versions of the application can be brought up by the following steps:

=== Installing and deploying a MYSql on Mac OSX
[source]
----
brew install mysql
mysql.server start
mysql -u root

CREATE USER 'springpong'@'localhost' IDENTIFIED BY 'springpong';
CREATE DATABASE pong_matcher_spring_development;
GRANT ALL ON pong_matcher_spring_development.* TO 'springpong'@'localhost';
----

=== Start the application
[source]
----
mvn spring-boot:run
----

=== Check if the application has started up
Try the endpoint available here - http://localhost:8080/courses

<table border="1" width="100%" cellspacing="3" cellpadding="3"><tbody><tr><th>Approaches</th><th>Pros</th><th>Cons</th></tr><tr><td>Approach 1 – Let Buildpack handle it</td><td>1. Simple, the application that works locally will work without any changes on the cloud</td><td>1. Magical – the auto-reconfiguration may appear magical to someone who does not understand the underlying flow<br> 2. The number of service types supported is fairly limited –<br> say for eg, if a connectivity is required to Cassandra then Auto-reconfiguration will not work</td></tr><tr><td>Approach 2 – Explicit Properties</td><td>1. Fairly straightforward.<br> 2. Follows the Spring Boot approach and uses some of the best practices of Boot based applications – for eg, there is a certain order in which datasource connection pools are created, all those best practices just flow in using this approach.</td><td>1. The Auto-reconfiguration will have to be explicitly disabled<br> 2. Need to know what the flattened properties look like<br> 3. A “cloud” profile may have to be manually injected through environment properties to differentiate local development and cloud deployment<br> 4. Difficult to encapsulate reusability of connectivity to newer service types – say Cassandra or DynamoDB.</td></tr><tr><td>Approach 3 – Spring Cloud Connectors</td><td>1. Simple to integrate<br> 2. Easy to add in re-usable integration to newer service types</td><td>1. Bypasses the optimizations of Spring Boot connection pool logic.</td></tr></tbody></table>
